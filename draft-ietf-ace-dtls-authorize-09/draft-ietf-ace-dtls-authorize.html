<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Datagram Transport Layer Security (DTLS) Profile for Authentication and Authorization for Constrained Environments (ACE)</title>

  <style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 Protocol Overview">
<link href="#rfc.section.3" rel="Chapter" title="3 Protocol Flow">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Communication between C and AS">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 RawPublicKey Mode">
<link href="#rfc.section.3.2.1" rel="Chapter" title="3.2.1 DTLS Channel Setup Between C and RS">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 PreSharedKey Mode">
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 DTLS Channel Setup Between C and RS">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Resource Access">
<link href="#rfc.section.4" rel="Chapter" title="4 Dynamic Update of Authorization Information">
<link href="#rfc.section.5" rel="Chapter" title="5 Token Expiration">
<link href="#rfc.section.6" rel="Chapter" title="6 Secure Communication with AS">
<link href="#rfc.section.7" rel="Chapter" title="7 Security Considerations">
<link href="#rfc.section.8" rel="Chapter" title="8 Privacy Considerations">
<link href="#rfc.section.9" rel="Chapter" title="9 IANA Considerations">
<link href="#rfc.references" rel="Chapter" title="10 References">
<link href="#rfc.references.1" rel="Chapter" title="10.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="10.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.37.2 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Gerdes, S., Bergmann, O., Bormann, C., Selander, G., and L. Seitz" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-ace-dtls-authorize-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-12-18" />
  <meta name="dct.abstract" content="This specification defines a profile of the ACE framework that allows constrained servers to delegate client authentication and authorization.  The protocol relies on DTLS for communication security between entities in a constrained network using either raw public keys or pre-shared keys. A resource-constrained server can use this protocol to delegate management of authorization information to a trusted host with less severe limitations regarding processing power and memory." />
  <meta name="description" content="This specification defines a profile of the ACE framework that allows constrained servers to delegate client authentication and authorization.  The protocol relies on DTLS for communication security between entities in a constrained network using either raw public keys or pre-shared keys. A resource-constrained server can use this protocol to delegate management of authorization information to a trusted host with less severe limitations regarding processing power and memory." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">ACE Working Group</td>
<td class="right">S. Gerdes</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">O. Bergmann</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">C. Bormann</td>
</tr>
<tr>
<td class="left">Expires: June 20, 2020</td>
<td class="right">Universit&#228;t Bremen TZI</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">G. Selander</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Ericsson AB</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">L. Seitz</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Combitech</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">December 18, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Datagram Transport Layer Security (DTLS) Profile for Authentication and Authorization for Constrained Environments (ACE)<br />
  <span class="filename">draft-ietf-ace-dtls-authorize-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This specification defines a profile of the ACE framework that allows constrained servers to delegate client authentication and authorization.  The protocol relies on DTLS for communication security between entities in a constrained network using either raw public keys or pre-shared keys. A resource-constrained server can use this protocol to delegate management of authorization information to a trusted host with less severe limitations regarding processing power and memory.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on June 20, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Terminology</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Protocol Overview</a>
</li>
<li>3.   <a href="#rfc.section.3">Protocol Flow</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Communication between C and AS</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">RawPublicKey Mode</a>
</li>
<ul><li>3.2.1.   <a href="#rfc.section.3.2.1">DTLS Channel Setup Between C and RS</a>
</li>
</ul><li>3.3.   <a href="#rfc.section.3.3">PreSharedKey Mode</a>
</li>
<ul><li>3.3.1.   <a href="#rfc.section.3.3.1">DTLS Channel Setup Between C and RS</a>
</li>
</ul><li>3.4.   <a href="#rfc.section.3.4">Resource Access</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Dynamic Update of Authorization Information</a>
</li>
<li>5.   <a href="#rfc.section.5">Token Expiration</a>
</li>
<li>6.   <a href="#rfc.section.6">Secure Communication with AS</a>
</li>
<li>7.   <a href="#rfc.section.7">Security Considerations</a>
</li>
<li>8.   <a href="#rfc.section.8">Privacy Considerations</a>
</li>
<li>9.   <a href="#rfc.section.9">IANA Considerations</a>
</li>
<li>10.   <a href="#rfc.references">References</a>
</li>
<ul><li>10.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>10.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">This specification defines a profile of the ACE framework <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>.  In this profile, a client and a resource server use CoAP <a href="#RFC7252" class="xref">[RFC7252]</a> over DTLS <a href="#RFC6347" class="xref">[RFC6347]</a> to communicate. The client obtains an access token, bound to a key (the proof-of-possession key), from an authorization server to prove its authorization to access protected resources hosted by the resource server. Also, the client and the resource server are provided by the authorization server with the necessary keying material to establish a DTLS session. The communication between client and authorization server may also be secured with DTLS.  This specification supports DTLS with Raw Public Keys (RPK) <a href="#RFC7250" class="xref">[RFC7250]</a> and with Pre-Shared Keys (PSK) <a href="#RFC4279" class="xref">[RFC4279]</a>.</p>
<p id="rfc.section.1.p.2">The DTLS handshake requires the client and server to prove that they can use certain keying material. In the RPK mode, the client proves with the DTLS handshake that it can use the RPK bound to the token and the server shows that it can use a certain RPK. The access token must be presented to the resource server.  For the RPK mode, the access token needs to be uploaded to the resource server before the handshake is initiated, as described in Section 5.8.1 of the ACE framework <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>.</p>
<p id="rfc.section.1.p.3">In the PSK mode, client and server show with the DTLS handshake that they can use the keying material that is bound to the access token.  To transfer the access token from the client to the resource server, the <samp>psk_identity</samp> parameter in the DTLS PSK handshake may be used instead of uploading the token prior to the handshake.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.1.1.p.2">Readers are expected to be familiar with the terms and concepts described in <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a> and in <a href="#I-D.ietf-ace-oauth-params" class="xref">[I-D.ietf-ace-oauth-params]</a>.</p>
<p id="rfc.section.1.1.p.3">The authorization information (authz-info) resource refers to the authorization information endpoint as specified in <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#overview" id="overview">Protocol Overview</a>
</h1>
<p id="rfc.section.2.p.1">The CoAP-DTLS profile for ACE specifies the transfer of authentication information and, if necessary, authorization information between the client (C) and the resource server (RS) during setup of a DTLS session for CoAP messaging. It also specifies how C can use CoAP over DTLS to retrieve an access token from the authorization server (AS) for a protected resource hosted on the resource server.</p>
<p id="rfc.section.2.p.2">This profile requires the client to retrieve an access token for protected resource(s) it wants to access on RS as specified in <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>. <a href="#at-retrieval" class="xref">Figure 1</a> shows the typical message flow in this scenario (messages in square brackets are optional):</p>
<div id="rfc.figure.1"></div>
<div id="at-retrieval"></div>
<pre>
   C                                RS                   AS
   | [---- Resource Request ------&gt;]|                     |
   |                                |                     |
   | [&lt;-AS Request Creation Hints-] |                     |
   |                                |                     |
   | ------- Token Request  ----------------------------&gt; |
   |                                |                     |
   | &lt;---------------------------- Access Token --------- |
   |                               + Access Information   |

</pre>
<p class="figure">Figure 1: Retrieving an Access Token</p>
<p id="rfc.section.2.p.3">To determine the AS in charge of a resource hosted at the RS, C MAY send an initial Unauthorized Resource Request message to the RS. The RS then denies the request and sends an AS Request Creation Hints message containing the address of its AS back to the client as specified in Section 5.1.2 of <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>.</p>
<p id="rfc.section.2.p.4">Once the client knows the authorization server&#8217;s address, it can send an access token request to the token endpoint at the AS as specified in <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>. As the access token request as well as the response may contain confidential data, the communication between the client and the authorization server MUST be confidentiality-protected and ensure authenticity. C may have been registered at the AS via the OAuth 2.0 client registration mechanism as outlined in Section 5.3 of <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>.</p>
<p id="rfc.section.2.p.5">The access token returned by the authorization server can then be used by the client to establish a new DTLS session with the resource server. When the client intends to use an asymmetric proof-of-possession key in the DTLS handshake with the resource server, the client MUST upload the access token to the authz-info resource, i.e. the authz-info endpoint, on the resource server before starting the DTLS handshake, as described in Section 5.8.1 of <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>. In case the client uses a symmetric proof-of-possession key in the DTLS handshake, the procedure as above MAY be used, or alternatively, the access token MAY instead be transferred in the DTLS ClientKeyExchange message (see <a href="#psk-dtls-channel" class="xref">Section 3.3.1</a>).</p>
<p><a href="#protocol-overview" class="xref">Figure 2</a> depicts the common protocol flow for the DTLS profile after the client C has retrieved the access token from the authorization server AS.</p>
<div id="rfc.figure.2"></div>
<div id="protocol-overview"></div>
<pre>
   C                            RS                   AS
   | [--- Access Token ------&gt;] |                     |
   |                            |                     |
   | &lt;== DTLS channel setup ==&gt; |                     |
   |                            |                     |
   | == Authorized Request ===&gt; |                     |
   |                            |                     |
   | &lt;=== Protected Resource == |                     |

</pre>
<p class="figure">Figure 2: Protocol overview</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#protocol-flow" id="protocol-flow">Protocol Flow</a>
</h1>
<p id="rfc.section.3.p.1">The following sections specify how CoAP is used to interchange access-related data between the resource server, the client and the authorization server so that the authorization server can provide the client and the resource server with sufficient information to establish a secure channel, and convey authorization information specific for this communication relationship to the resource server.</p>
<p><a href="#C-AS-comm" class="xref">Section 3.1</a> describes how the communication between C and AS must be secured.  Depending on the used CoAP security mode (see also Section 9 of <a href="#RFC7252" class="xref">[RFC7252]</a>, the Client-to-AS request, AS-to-Client response and DTLS session establishment carry slightly different information. <a href="#rpk-mode" class="xref">Section 3.2</a> addresses the use of raw public keys while <a href="#psk-mode" class="xref">Section 3.3</a> defines how pre-shared keys are used in this profile.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#C-AS-comm" id="C-AS-comm">Communication between C and AS</a>
</h1>
<p id="rfc.section.3.1.p.1">To retrieve an access token for the resource that the client wants to access, the client requests an access token from the authorization server. Before C can request the access token, C and AS MUST establish a secure communication channel. C MUST securely have obtained keying material to communicate with AS. Furthermore, C MUST verify that AS is authorized to provide access tokens (including authorization information) about RS to C.  Also, AS MUST securely have obtained keying material for C, and obtained authorization rules approved by the resource owner (RO) concerning C and RS that relate to this keying material. C and AS MUST use their respective keying material for all exchanged messages. How the security association between C and AS is bootstrapped is not part of this document. C and AS MUST ensure the confidentiality, integrity and authenticity of all exchanged messages.</p>
<p id="rfc.section.3.1.p.2">Section <a href="#as-commsec" class="xref">Section 6</a> specifies how communication with the AS is secured.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#rpk-mode" id="rpk-mode">RawPublicKey Mode</a>
</h1>
<p id="rfc.section.3.2.p.1">After C and AS mutually authenticated each other and validated each other&#8217;s authorization, C sends a token request to AS&#8217;s token endpoint.  The client MUST add a <samp>req_cnf</samp> object carrying either its raw public key or a unique identifier for a public key that it has previously made known to the authorization server. To prove that the client is in possession of this key, C MUST use the same keying material that it uses to secure the communication with AS, e.g., the DTLS session.</p>
<p id="rfc.section.3.2.p.2">An example access token request from the client to the AS is depicted in <a href="#rpk-authorization-message-example" class="xref">Figure 3</a>.</p>
<div id="rfc.figure.3"></div>
<div id="rpk-authorization-message-example"></div>
<pre>
   POST coaps://as.example.com/token
   Content-Format: application/ace+cbor
   Payload:
   {
     grant_type : client_credentials,
     req_aud    : "tempSensor4711",
     req_cnf    : {
       COSE_Key : {
         kty : EC2,
         crv : P-256,
         x   : h'e866c35f4c3c81bb96a1...',
         y   : h'2e25556be097c8778a20...'
       }
     }
   }
</pre>
<p class="figure">Figure 3: Access Token Request Example for RPK Mode</p>
<p id="rfc.section.3.2.p.3">The example shows an access token request for the resource identified by the string &#8220;tempSensor4711&#8221; on the authorization server using a raw public key.</p>
<p id="rfc.section.3.2.p.4">AS MUST check if the client that it communicates with is associated with the RPK in the cnf object before issuing an access token to it.  If AS determines that the request is to be authorized according to the respective authorization rules, it generates an access token response for C. The access token MUST be bound to the RPK of the client by means of the cnf claim.  The response MAY contain a <samp>profile</samp> parameter with the value <samp>coap_dtls</samp> to indicate that this profile MUST be used for communication between the client C and the resource server. The <samp>profile</samp> may be specified out-of-band, in which case it does not have to be sent. The response also contains an access token and an <samp>rs_cnf</samp> parameter containing information about the public key that is used by the resource server. AS MUST ascertain that the RPK specified in <samp>rs_cnf</samp> belongs to the resource server that C wants to communicate with. AS MUST protect the integrity of the token. If the access token contains confidential data, AS MUST also protect the confidentiality of the access token.</p>
<p id="rfc.section.3.2.p.5">C MUST ascertain that the access token response belongs to a certain previously sent access token request, as the request may specify the resource server with which C wants to communicate.</p>
<p id="rfc.section.3.2.p.6">An example access token response from the AS to the client is depicted in <a href="#rpk-authorization-response-example" class="xref">Figure 4</a>.</p>
<div id="rfc.figure.4"></div>
<div id="rpk-authorization-response-example"></div>
<pre>
   2.01 Created
   Content-Format: application/ace+cbor
   Max-Age: 3600
   Payload:
   {
     access_token : b64'SlAV32hkKG...
      (remainder of CWT omitted for brevity;
      CWT contains clients RPK in the cnf claim)',
     expires_in : 3600,
     rs_cnf     : {
       COSE_Key : {
         kty : EC2,
         crv : P-256,
         x   : h'd7cc072de2205bdc1537...',
         y   : h'f95e1d4b851a2cc80fff...'
       }
     }
   }
</pre>
<p class="figure">Figure 4: Access Token Response Example for RPK Mode</p>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#rpk-dtls-channel" id="rpk-dtls-channel">DTLS Channel Setup Between C and RS</a>
</h1>
<p id="rfc.section.3.2.1.p.1">Before the client initiates the DTLS handshake with the resource server, C MUST send a <samp>POST</samp> request containing the new access token to the authz-info resource hosted by the resource server. After the client<br> receives a confirmation that the RS has accepted the access token, it SHOULD proceed to establish a new DTLS channel with the resource server. To use the RawPublicKey mode, the client MUST specify the public key that AS defined in the <samp>cnf</samp> field of the access token response in the SubjectPublicKeyInfo structure in the DTLS handshake as specified in <a href="#RFC7250" class="xref">[RFC7250]</a>.</p>
<p id="rfc.section.3.2.1.p.2">An implementation that supports the RPK mode of this profile MUST at least support the ciphersuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 <a href="#RFC7251" class="xref">[RFC7251]</a> with the ed25519 curve (cf. <a href="#RFC8032" class="xref">[RFC8032]</a>, <a href="#RFC8422" class="xref">[RFC8422]</a>).</p>
<p></p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">According to <a href="#RFC7252" class="xref">[RFC7252]</a>, CoAP implementations MUST support the ciphersuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 <a href="#RFC7251" class="xref">[RFC7251]</a> and the NIST P-256 curve. As discussed in <a href="#RFC7748" class="xref">[RFC7748]</a>, new ECC curves have been defined recently that are considered superior to the so-called NIST curves. The curve that is mandatory to implement in this specification is said to be efficient and less dangerous regarding implementation errors than the secp256r1 curve mandated in <a href="#RFC7252" class="xref">[RFC7252]</a>.</dd>
</dl>
<p id="rfc.section.3.2.1.p.4">RS MUST check if the access token is still valid, if RS is the intended destination, i.e., the audience, of the token, and if the token was issued by an authorized AS.  The access token is constructed by the authorization server such that the resource server can associate the access token with the Client&#8217;s public key.  The <samp>cnf</samp> claim MUST contain either C&#8217;s RPK or, if the key is already known by the resource server (e.g., from previous communication), a reference to this key. If the authorization server has no certain knowledge that the Client&#8217;s key is already known to the resource server, the Client&#8217;s public key MUST be included in the access token&#8217;s <samp>cnf</samp> parameter. If CBOR web tokens <a href="#RFC8392" class="xref">[RFC8392]</a> are used as recommended in <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>, keys MUST be encoded as specified in <a href="#I-D.ietf-ace-cwt-proof-of-possession" class="xref">[I-D.ietf-ace-cwt-proof-of-possession]</a>.  RS MUST use the keying material in the handshake that AS specified in the rs_cnf parameter in the access token. Thus, the handshake only finishes if C and RS are able to use their respective keying material.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#psk-mode" id="psk-mode">PreSharedKey Mode</a>
</h1>
<p id="rfc.section.3.3.p.1">To retrieve an access token for the resource that the client wants to access, the client MAY include a <samp>cnf</samp> object carrying an identifier for a symmetric key in its access token request to the authorization server.  This identifier can be used by the authorization server to determine the shared secret to construct the proof-of-possession token.  AS MUST check if the identifier refers to a symmetric key that was previously generated by AS as a shared secret for the communication between this client and the resource server.</p>
<p id="rfc.section.3.3.p.2">The authorization server MUST determine the authorization rules for the C it communicates with as defined by RO and generate the access token accordingly.  If the authorization server authorizes the client, it returns an AS-to-Client response. If the profile parameter is present, it is set to <samp>coap_dtls</samp>. AS MUST ascertain that the access token is generated for the resource server that C wants to communicate with. Also, AS MUST protect the integrity of the access token. If the token contains confidential data such as the symmetric key, the confidentiality of the token MUST also be protected. Depending on the requested token type and algorithm in the access token request, the authorization server adds access Information to the response that provides the client with sufficient information to setup a DTLS channel with the resource server. AS adds a <samp>cnf</samp> parameter to the access information carrying a <samp>COSE_Key</samp> object that informs the client about the symmetric key that is to be used between C and the resource server. The access token MUST be bound to the same symmetric key by means of the cnf claim.</p>
<p id="rfc.section.3.3.p.3">An example access token request for an access token with a symmetric proof-of-possession key is illustrated in <a href="#at-request" class="xref">Figure 5</a>.</p>
<div id="rfc.figure.5"></div>
<div id="at-request"></div>
<pre>
   POST coaps://as.example.com/token
   Content-Format: application/ace+cbor
   Payload:
   {
     audience    : "smokeSensor1807",
   }
</pre>
<p class="figure">Figure 5: Example Access Token Request, symmetric PoP-key</p>
<p id="rfc.section.3.3.p.4">An example access token response is illustrated in <a href="#at-response" class="xref">Figure 6</a>.  In this example, the authorization server returns a 2.01 response containing a new access token and information for the client, including the symmetric key in the cnf claim.  The information is transferred as a CBOR data structure as specified in <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>.</p>
<div id="rfc.figure.6"></div>
<div id="at-response"></div>
<pre>
   2.01 Created
   Content-Format: application/ace+cbor
   Max-Age: 86400
   Payload:
   {
      access_token : h'd08343a10...
      (remainder of CWT omitted for brevity)
      token_type : pop,
      expires_in : 86400,
      profile    : coap_dtls,
      cnf        : {
        COSE_Key : {
          kty : symmetric,
          kid : h'3d027833fc6267ce',
          k   : h'73657373696f6e6b6579'
        }
      }
   }
</pre>
<p class="figure">Figure 6: Example Access Token Response, symmetric PoP-key</p>
<p id="rfc.section.3.3.p.5">The access token also comprises a <samp>cnf</samp> claim. This claim usually contains a <samp>COSE_Key</samp> object that carries either the symmetric key itself or a key identifier that can be used by the resource server to determine the secret key shared with the client. If the access token carries a symmetric key, the access token MUST be encrypted using a <samp>COSE_Encrypt0</samp> structure. The AS MUST use the keying material shared with the RS to encrypt the token.</p>
<p id="rfc.section.3.3.p.6">The <samp>cnf</samp> structure in the access token is provided in <a href="#kdf-cnf" class="xref">Figure 7</a>.</p>
<div id="rfc.figure.7"></div>
<div id="kdf-cnf"></div>
<pre>
cnf : {
  COSE_Key : {
    kty : symmetric,
    kid : h'6549694f464361396c4f6277'
  }
}
</pre>
<p class="figure">Figure 7: Access Token without Keying Material</p>
<p id="rfc.section.3.3.p.7">A response that declines any operation on the requested resource is constructed according to Section 5.2 of <a href="#RFC6749" class="xref">[RFC6749]</a>, (cf. Section 5.6.3. of <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>).</p>
<div id="rfc.figure.8"></div>
<div id="token-reject"></div>
<pre>
    4.00 Bad Request
    Content-Format: application/ace+cbor
    Payload:
    {
      error : invalid_request
    }
</pre>
<p class="figure">Figure 8: Example Access Token Response With Reject</p>
<p id="rfc.section.3.3.p.8">The method for how the resource server determines the symmetric key from an access token containing only a key identifier is application specific, the remainder of this section provides one example.</p>
<p id="rfc.section.3.3.p.9">The AS and the resource server are assumed to share a key derivation key used to derive the symmetric key shared with the client from the key identifier in the access token.  The key derivation key may be derived from some other secret key shared between the AS and the resource server. This key needs to be securely stored and processed in the same way as the key used to protect the communication between AS and RS.</p>
<p id="rfc.section.3.3.p.10">Knowledge of the symmetric key shared with the client must not reveal any information about the key derivation key or other secret keys shared between AS and resource server.</p>
<p id="rfc.section.3.3.p.11">In order to generate a new symmetric key to be used by client and resource server, the AS generates a key identifier and uses the key derivation key shared with the resource server to derive the symmetric key as specified below. Instead of providing the keying material in the access token, the AS includes the key identifier in the <samp>kid</samp> parameter, see <a href="#kdf-cnf" class="xref">Figure 7</a>. This key identifier enables the resource server to calculate the keying material for the communication with the client from the access token using the key derivation key and following Section 11 of <a href="#RFC8152" class="xref">[RFC8152]</a> with parameters as specified here. The KDF to be used needs to be defined by the application, for example HKDF-SHA-256. The key identifier picked by the AS needs to be unique for each access token where a unique symmetric key is required.</p>
<p id="rfc.section.3.3.p.12">The fields in the context information <samp>COSE_KDF_Context</samp> (Section 11.2 of <a href="#RFC8152" class="xref">[RFC8152]</a>) have the following values:</p>
<p></p>

<ul>
<li>AlgorithmID = &#8220;ACE-CoAP-DTLS-key-derivation&#8221;</li>
<li>PartyUInfo = PartyVInfo = ( null, null, null )</li>
<li>keyDataLength needs to be defined by the application</li>
<li>protected MUST be a zero length bstr</li>
<li>other is a zero length bstr</li>
<li>SuppPrivInfo is omitted</li>
</ul>
<h1 id="rfc.section.3.3.1">
<a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#psk-dtls-channel" id="psk-dtls-channel">DTLS Channel Setup Between C and RS</a>
</h1>
<p id="rfc.section.3.3.1.p.1">When a client receives an access token response from an authorization server, C MUST ascertain that the access token response belongs to a certain previously sent access token request, as the request may specify the resource server with which C wants to communicate.</p>
<p id="rfc.section.3.3.1.p.2">C checks if the payload of the access token response contains an <samp>access_token</samp> parameter and a <samp>cnf</samp> parameter. With this information the client can initiate the establishment of a new DTLS channel with a resource server. To use DTLS with pre-shared keys, the client follows the PSK key exchange algorithm specified in Section 2 of <a href="#RFC4279" class="xref">[RFC4279]</a> using the key conveyed in the <samp>cnf</samp> parameter of the AS response as PSK when constructing the premaster secret.</p>
<p id="rfc.section.3.3.1.p.3">In PreSharedKey mode, the knowledge of the shared secret by the client and the resource server is used for mutual authentication between both peers. Therefore, the resource server must be able to determine the shared secret from the access token. Following the general ACE authorization framework, the client can upload the access token to the resource server&#8217;s authz-info resource before starting the DTLS handshake. Alternatively, the client MAY provide the most recent access token in the <samp>psk_identity</samp> field of the ClientKeyExchange message. To do so, the client MUST treat the contents of the <samp>access_token</samp> field from the AS-to-Client response as opaque data and not perform any re-coding.</p>
<p></p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">As stated in Section 4.2 of <a href="#RFC7925" class="xref">[RFC7925]</a>, the PSK identity should be treated as binary data in the Internet of Things space and not assumed to have a human-readable form of any sort.</dd>
</dl>
<p id="rfc.section.3.3.1.p.5">If a resource server receives a ClientKeyExchange message that contains a <samp>psk_identity</samp> with a length greater zero, it uses the contents as index for its key store (i.e., treat the contents as key identifier). The resource server MUST check if it has one or more access tokens that are associated with the specified key.</p>
<p id="rfc.section.3.3.1.p.6">If no key with a matching identifier is found, the resource server MAY process the contents of the <samp>psk_identity</samp> field as access token that is stored with the authorization information endpoint, before continuing the DTLS handshake. If the contents of the <samp>psk_identity</samp> do not yield a valid access token for the requesting client, the DTLS session setup is terminated with an <samp>illegal_parameter</samp> DTLS alert message.</p>
<p></p>

<dl>
<dt>Note1:</dt>
<dd style="margin-left: 8">As a resource server cannot provide a client with a meaningful PSK identity hint in response to the client&#8217;s ClientHello message, the resource server SHOULD NOT send a ServerKeyExchange message.</dd>
<dt>Note2:</dt>
<dd style="margin-left: 8">According to <a href="#RFC7252" class="xref">[RFC7252]</a>, CoAP implementations MUST support the ciphersuite TLS_PSK_WITH_AES_128_CCM_8 <a href="#RFC6655" class="xref">[RFC6655]</a>. A client is therefore expected to offer at least this ciphersuite to the resource server.</dd>
</dl>
<p id="rfc.section.3.3.1.p.8">When RS receives an access token, RS MUST check if the access token is still valid, if RS is the intended destination, i.e., the audience of the token, and if the token was issued by an authorized AS.  This specification assumes that the access token is a PoP token as described in <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a> unless specifically stated otherwise. Therefore, the access token is bound to a symmetric PoP key that is used as shared secret between the client and the resource server.</p>
<p id="rfc.section.3.3.1.p.9">While the client can retrieve the shared secret from the contents of the <samp>cnf</samp> parameter in the AS-to-Client response, the resource server uses the information contained in the <samp>cnf</samp> claim of the access token to determine the actual secret when no explicit <samp>kid</samp> was provided in the <samp>psk_identity</samp> field. If key derivation is used, the RS uses the <samp>COSE_KDF_Context</samp> information as described above.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#resource-access" id="resource-access">Resource Access</a>
</h1>
<p id="rfc.section.3.4.p.1">Once a DTLS channel has been established as described in <a href="#rpk-mode" class="xref">Section 3.2</a> and <a href="#psk-mode" class="xref">Section 3.3</a>, respectively, the client is authorized to access resources covered by the access token it has uploaded to the authz-info resource hosted by the resource server.</p>
<p id="rfc.section.3.4.p.2">With the successful establishment of the DTLS channel, C and RS have proven that they can use their respective keying material. An access token that is bound to the client&#8217;s keying material is associated with the channel. Any request that the resource server receives on this channel MUST be checked against these authorization rules. RS MUST check for every request if the access token is still valid.  Incoming CoAP requests that are not authorized with respect to any access token that is associated with the client MUST be rejected by the resource server with 4.01 response as described in Section 5.1.1 of <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>.</p>
<p id="rfc.section.3.4.p.3">The resource server SHOULD treat an incoming CoAP request as authorized if the following holds:</p>
<p></p>

<ol>
<li>The message was received on a secure channel that has been established using the procedure defined in this document.</li>
<li>The authorization information tied to the sending client is valid.</li>
<li>The request is destined for the resource server.</li>
<li>The resource URI specified in the request is covered by the authorization information.</li>
<li>The request method is an authorized action on the resource with respect to the authorization information.</li>
</ol>
<p id="rfc.section.3.4.p.5">Incoming CoAP requests received on a secure DTLS channel that are not thus authorized MUST be rejected according to Section 5.8.2 of <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a></p>
<p></p>

<ol>
<li>with response code 4.03 (Forbidden) when the resource URI specified in the request is not covered by the authorization information, and</li>
<li>with response code 4.05 (Method Not Allowed) when the resource URI specified in the request covered by the authorization information but not the requested action.</li>
</ol>
<p id="rfc.section.3.4.p.7">The client cannot always know a priori if an Authorized Resource Request will succeed. It MUST check the validity of its keying material before sending a request or processing a response.  If the client repeatedly gets error responses containing AS Creation Hints (cf.  Section 5.1.2 of <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a> as response to its requests, it SHOULD request a new access token from the authorization server in order to continue communication with the resource server.</p>
<p id="rfc.section.3.4.p.8">Unauthorized requests that have been received over a DTLS session SHOULD be treated as non-fatal by the RS, i.e., the DTLS session SHOULD be kept alive until the associated access token has expired.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#update" id="update">Dynamic Update of Authorization Information</a>
</h1>
<p id="rfc.section.4.p.1">The client can update the authorization information stored at the resource server at any time without changing an established DTLS session. To do so, the Client requests a new access token from the authorization server for the intended action on the respective resource and uploads this access token to the authz-info resource on the resource server.</p>
<p><a href="#update-overview" class="xref">Figure 9</a> depicts the message flow where the C requests a new access token after a security association between the client and the resource server has been established using this protocol. If the client wants to update the authorization information, the token request MUST specify the key identifier of the proof-of-possession key used for the existing DTLS channel between the client and the resource server in the <samp>kid</samp> parameter of the Client-to-AS request. The authorization server MUST verify that the specified <samp>kid</samp> denotes a valid verifier for a proof-of-possession token that has previously been issued to the requesting client. Otherwise, the Client-to-AS request MUST be declined with the error code <samp>unsupported_pop_key</samp> as defined in Section 5.6.3 of <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>.</p>
<p id="rfc.section.4.p.3">When the authorization server issues a new access token to update existing authorization information, it MUST include the specified <samp>kid</samp> parameter in this access token. A resource server MUST replace the authorization information of any existing DTLS session that is identified by this key identifier with the updated authorization information.</p>
<p></p>

<dl>
<dt>Note:</dt>
<dd style="margin-left: 8">By associating the access tokens with the identifier of an existing DTLS session, the authorization information can be updated without changing the cryptographic keys for the DTLS communication between the client and the resource server, i.e. an existing session can be used with updated permissions.</dd>
</dl>
<div id="rfc.figure.9"></div>
<div id="update-overview"></div>
<pre>
   C                            RS                   AS
   | &lt;===== DTLS channel =====&gt; |                     |
   |        + Access Token      |                     |
   |                            |                     |
   | --- Token Request  ----------------------------&gt; |
   |                            |                     |
   | &lt;---------------------------- New Access Token - |
   |                           + Access Information   |
   |                            |                     |
   | --- Update /authz-info --&gt; |                     |
   |     New Access Token       |                     |
   |                            |                     |
   | == Authorized Request ===&gt; |                     |
   |                            |                     |
   | &lt;=== Protected Resource == |                     |

</pre>
<p class="figure">Figure 9: Overview of Dynamic Update Operation</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#teardown" id="teardown">Token Expiration</a>
</h1>
<p id="rfc.section.5.p.1">DTLS sessions that have been established in accordance with this profile are always tied to a specific access token. As this token may become invalid at any time (e.g. because it has expired), the session may become useless at some point. A resource server therefore MUST terminate existing DTLS sessions after the access token for this session has been deleted.</p>
<p id="rfc.section.5.p.2">As specified in Section 5.8.3 of <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>, the resource server MUST notify the client with an error response with code 4.01 (Unauthorized) for any long running request before terminating the session.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#as-commsec" id="as-commsec">Secure Communication with AS</a>
</h1>
<p id="rfc.section.6.p.1">As specified in the ACE framework (sections 5.6 and 5.7 of <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>), the requesting entity (RS and/or client) and the AS communicate via the token endpoint or introspection endpoint.  The use of CoAP and DTLS for this communication is RECOMMENDED in this profile, other protocols (such as HTTP and TLS or CoAP and OSCORE) MAY be used instead.</p>
<p id="rfc.section.6.p.2">How credentials (e.g., PSK, RPK, X.509 cert) for using DTLS with the AS are established is out of scope for this profile.</p>
<p id="rfc.section.6.p.3">If other means of securing the communication with the AS are used, the security protocol MUST fulfill the communication security requirements in Section 6.2 of <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.7.p.1">This document specifies a profile for the Authentication and Authorization for Constrained Environments (ACE) framework <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>. As it follows this framework&#8217;s general approach, the general security considerations from section 6 also apply to this profile.</p>
<p id="rfc.section.7.p.2">When using pre-shared keys provisioned by the AS, the security level depends on the randomness of PSK, and the security of the TLS cipher suite and key exchange algorithm.</p>
<p id="rfc.section.7.p.3">Constrained devices that use DTLS <a href="#RFC6347" class="xref">[RFC6347]</a> are inherently vulnerable to Denial of Service (DoS) attacks as the handshake protocol requires creation of internal state within the device.  This is specifically of concern where an adversary is able to intercept the initial cookie exchange and interject forged messages with a valid cookie to continue with the handshake. A similar issue exists with the authorization information endpoint where the resource server needs to keep valid access tokens until their expiry. Adversaries can fill up the constrained resource server&#8217;s internal storage for a very long time with interjected or otherwise retrieved valid access tokens.</p>
<p id="rfc.section.7.p.4">The use of multiple access tokens for a single client increases the strain on the resource server as it must consider every access token and calculate the actual permissions of the client. Also, tokens may contradict each other which may lead the server to enforce wrong permissions. If one of the access tokens expires earlier than others, the resulting permissions may offer insufficient protection. Developers SHOULD avoid using multiple access tokens for a client.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#privacy-considerations" id="privacy-considerations">Privacy Considerations</a>
</h1>
<p id="rfc.section.8.p.1">This privacy considerations from section 7 of the <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a> apply also to this profile.</p>
<p id="rfc.section.8.p.2">An unprotected response to an unauthorized request may disclose information about the resource server and/or its existing relationship with the client. It is advisable to include as little information as possible in an unencrypted response. When a DTLS session between the client and the resource server already exists, more detailed information MAY be included with an error response to provide the client with sufficient information to react on that particular error.</p>
<p id="rfc.section.8.p.3">Also, unprotected requests to the resource server may reveal information about the client, e.g., which resources the client attempts to request or the data that the client wants to provide to the resource server. The client SHOULD NOT send confidential data in an unprotected request.</p>
<p id="rfc.section.8.p.4">Note that some information might still leak after DTLS session is established, due to observable message sizes, the source, and the destination addresses.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.9.p.1">The following registrations are done for the ACE OAuth Profile Registry following the procedure specified in <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>.</p>
<p id="rfc.section.9.p.2">Note to RFC Editor: Please replace all occurrences of &#8220;[RFC-XXXX]&#8221; with the RFC number of this specification and delete this paragraph.</p>
<p id="rfc.section.9.p.3">Profile name: coap_dtls</p>
<p id="rfc.section.9.p.4">Profile Description: Profile for delegating client authentication and authorization in a constrained environment by establishing a Datagram Transport Layer Security (DTLS) channel between resource-constrained nodes.</p>
<p id="rfc.section.9.p.5">Profile ID:  1</p>
<p id="rfc.section.9.p.6">Change Controller:  IESG</p>
<p id="rfc.section.9.p.7">Reference:  [RFC-XXXX]</p>
<h1 id="rfc.references">
<a href="#rfc.references">10.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">10.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-ace-cwt-proof-of-possession">[I-D.ietf-ace-cwt-proof-of-possession]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Seitz, L.</a>, <a>Selander, G.</a>, <a>Erdtman, S.</a> and <a>H. Tschofenig</a>, "<a href="https://tools.ietf.org/html/draft-ietf-ace-cwt-proof-of-possession-11">Proof-of-Possession Key Semantics for CBOR Web Tokens (CWTs)</a>", Internet-Draft draft-ietf-ace-cwt-proof-of-possession-11, October 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-ace-oauth-authz">[I-D.ietf-ace-oauth-authz]</b></td>
<td class="top">
<a>Seitz, L.</a>, <a>Selander, G.</a>, <a>Wahlstroem, E.</a>, <a>Erdtman, S.</a> and <a>H. Tschofenig</a>, "<a href="https://tools.ietf.org/html/draft-ietf-ace-oauth-authz-29">Authentication and Authorization for Constrained Environments (ACE) using the OAuth 2.0 Framework (ACE-OAuth)</a>", Internet-Draft draft-ietf-ace-oauth-authz-29, December 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-ace-oauth-params">[I-D.ietf-ace-oauth-params]</b></td>
<td class="top">
<a>Seitz, L.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-ace-oauth-params-07">Additional OAuth Parameters for Authorization in Constrained Environments (ACE)</a>", Internet-Draft draft-ietf-ace-oauth-params-07, December 2019.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4279">[RFC4279]</b></td>
<td class="top">
<a>Eronen, P.</a> and <a>H. Tschofenig</a>, "<a href="https://tools.ietf.org/html/rfc4279">Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)</a>", RFC 4279, DOI 10.17487/RFC4279, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6347">[RFC6347]</b></td>
<td class="top">
<a>Rescorla, E.</a> and <a>N. Modadugu</a>, "<a href="https://tools.ietf.org/html/rfc6347">Datagram Transport Layer Security Version 1.2</a>", RFC 6347, DOI 10.17487/RFC6347, January 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6749">[RFC6749]</b></td>
<td class="top">
<a>Hardt, D.</a>, "<a href="https://tools.ietf.org/html/rfc6749">The OAuth 2.0 Authorization Framework</a>", RFC 6749, DOI 10.17487/RFC6749, October 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7252">[RFC7252]</b></td>
<td class="top">
<a>Shelby, Z.</a>, <a>Hartke, K.</a> and <a>C. Bormann</a>, "<a href="https://tools.ietf.org/html/rfc7252">The Constrained Application Protocol (CoAP)</a>", RFC 7252, DOI 10.17487/RFC7252, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7925">[RFC7925]</b></td>
<td class="top">
<a>Tschofenig, H.</a> and <a>T. Fossati</a>, "<a href="https://tools.ietf.org/html/rfc7925">Transport Layer Security (TLS) / Datagram Transport Layer Security (DTLS) Profiles for the Internet of Things</a>", RFC 7925, DOI 10.17487/RFC7925, July 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8152">[RFC8152]</b></td>
<td class="top">
<a>Schaad, J.</a>, "<a href="https://tools.ietf.org/html/rfc8152">CBOR Object Signing and Encryption (COSE)</a>", RFC 8152, DOI 10.17487/RFC8152, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">10.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC6655">[RFC6655]</b></td>
<td class="top">
<a>McGrew, D.</a> and <a>D. Bailey</a>, "<a href="https://tools.ietf.org/html/rfc6655">AES-CCM Cipher Suites for Transport Layer Security (TLS)</a>", RFC 6655, DOI 10.17487/RFC6655, July 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7250">[RFC7250]</b></td>
<td class="top">
<a>Wouters, P.</a>, <a>Tschofenig, H.</a>, <a>Gilmore, J.</a>, <a>Weiler, S.</a> and <a>T. Kivinen</a>, "<a href="https://tools.ietf.org/html/rfc7250">Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)</a>", RFC 7250, DOI 10.17487/RFC7250, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7251">[RFC7251]</b></td>
<td class="top">
<a>McGrew, D.</a>, <a>Bailey, D.</a>, <a>Campagna, M.</a> and <a>R. Dugal</a>, "<a href="https://tools.ietf.org/html/rfc7251">AES-CCM Elliptic Curve Cryptography (ECC) Cipher Suites for TLS</a>", RFC 7251, DOI 10.17487/RFC7251, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7748">[RFC7748]</b></td>
<td class="top">
<a>Langley, A.</a>, <a>Hamburg, M.</a> and <a>S. Turner</a>, "<a href="https://tools.ietf.org/html/rfc7748">Elliptic Curves for Security</a>", RFC 7748, DOI 10.17487/RFC7748, January 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8032">[RFC8032]</b></td>
<td class="top">
<a>Josefsson, S.</a> and <a>I. Liusvaara</a>, "<a href="https://tools.ietf.org/html/rfc8032">Edwards-Curve Digital Signature Algorithm (EdDSA)</a>", RFC 8032, DOI 10.17487/RFC8032, January 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8392">[RFC8392]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Wahlstroem, E.</a>, <a>Erdtman, S.</a> and <a>H. Tschofenig</a>, "<a href="https://tools.ietf.org/html/rfc8392">CBOR Web Token (CWT)</a>", RFC 8392, DOI 10.17487/RFC8392, May 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8422">[RFC8422]</b></td>
<td class="top">
<a>Nir, Y.</a>, <a>Josefsson, S.</a> and <a>M. Pegourie-Gonnard</a>, "<a href="https://tools.ietf.org/html/rfc8422">Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier</a>", RFC 8422, DOI 10.17487/RFC8422, August 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Stefanie Gerdes</span> 
	  <span class="n hidden">
		<span class="family-name">Gerdes</span>
	  </span>
	</span>
	<span class="org vcardline">Universit&#228;t Bremen TZI</span>
	<span class="adr">
	  <span class="vcardline">Postfach 330440</span>

	  <span class="vcardline">
		<span class="locality">Bremen</span>,  
		<span class="region"></span>
		<span class="code">D-28359</span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">Phone: +49-421-218-63906</span>

<span class="vcardline">EMail: <a href="mailto:gerdes@tzi.org">gerdes@tzi.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Olaf Bergmann</span> 
	  <span class="n hidden">
		<span class="family-name">Bergmann</span>
	  </span>
	</span>
	<span class="org vcardline">Universit&#228;t Bremen TZI</span>
	<span class="adr">
	  <span class="vcardline">Postfach 330440</span>

	  <span class="vcardline">
		<span class="locality">Bremen</span>,  
		<span class="region"></span>
		<span class="code">D-28359</span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">Phone: +49-421-218-63904</span>

<span class="vcardline">EMail: <a href="mailto:bergmann@tzi.org">bergmann@tzi.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Carsten Bormann</span> 
	  <span class="n hidden">
		<span class="family-name">Bormann</span>
	  </span>
	</span>
	<span class="org vcardline">Universit&#228;t Bremen TZI</span>
	<span class="adr">
	  <span class="vcardline">Postfach 330440</span>

	  <span class="vcardline">
		<span class="locality">Bremen</span>,  
		<span class="region"></span>
		<span class="code">D-28359</span>
	  </span>
	  <span class="country-name vcardline">Germany</span>
	</span>
	<span class="vcardline">Phone: +49-421-218-63921</span>

<span class="vcardline">EMail: <a href="mailto:cabo@tzi.org">cabo@tzi.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">G&#246;ran Selander</span> 
	  <span class="n hidden">
		<span class="family-name">Selander</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson AB</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:goran.selander@ericsson.com">goran.selander@ericsson.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ludwig Seitz</span> 
	  <span class="n hidden">
		<span class="family-name">Seitz</span>
	  </span>
	</span>
	<span class="org vcardline">Combitech</span>
	<span class="adr">
	  <span class="vcardline">Dj&#228;knegatan 31</span>

	  <span class="vcardline">
		<span class="locality">Malm&#246;</span>,  
		<span class="region"></span>
		<span class="code">211 35</span>
	  </span>
	  <span class="country-name vcardline">Sweden</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ludwig.seitz@combitech.se">ludwig.seitz@combitech.se</a></span>

  </address>
</div>

  <div class="github-fork-ribbon-wrapper"><div class="github-fork-ribbon"><a href="https://github.com/ace-wg/ace-dtls-profile">Fork me on GitHub</a></div></div>
</body>
</html>
